<?php




class expressopinionlitevoteModuleFrontController extends ModuleFrontController
{
  
    public function initContent()
    {
        parent::initContent();

        $requestData = $this->getRequestData();

        if (!empty($requestData['errors'])) {
            return $this->jsonResponse(['message' => 'Erreur dans les données de la requête', 'errors' => $requestData['errors']], 400);
        }

        if (!$this->verifQuestion($requestData['idQuestion'], $requestData['idReponse'])) {
            return $this->jsonResponse(['message' => 'Erreur dans la vérification de la requête'], 400);
        }
        
            try {
                $this->insertVote($requestData['idQuestion'], $requestData['customerId']);
                $this->insertVoteHistory($requestData['idQuestion'], $requestData['idReponse'], $requestData['customerId']);
    

                $response = array(
                    'message' => 'Le formulaire a été traité avec succès'
                );
                return $this->jsonResponse($response, 200);
            } catch (\Throwable $th) {
                return $this->jsonResponse(['message' => $th->getMessage()], 400);
            }
        

        // Retourner une réponse JSON
        $response = array(
            'message' => 'Erreur',
        );
        return $this->jsonResponse($response, 400);

    }

    private function getRequestData()
    {
        $errors = [];

        $csrfToken = Tools::getValue('token');
        $idQuestion = (int) Tools::getValue('idQuestion');
        $idReponse = (int) Tools::getValue('idReponse');
        $customerId = (int) $this->context->customer->id;

        if (!$csrfToken) {
            $errors['token'] = 'Token CSRF manquant';
        }

        if (!$idQuestion || $idQuestion <= 0) {
            $errors['idQuestion'] = 'ID de question invalide';
        }

        if (!$idReponse || $idReponse <= 0) {
            $errors['idReponse'] = 'ID de réponse invalide';
        }

        if (!$customerId) {
            $errors['customerId'] = 'Pas d\'utilisateur connecté';
        }

        if (!empty($errors)) {
            return array('errors' => $errors);
        }

        return array(
            'csrfToken' => $csrfToken,
            'idQuestion' => $idQuestion,
            'idReponse' => $idReponse,
            'customerId' => $customerId
        );
    }


    private function verifQuestion($idquestion, $idReponse): bool
    {
        // Vérifier si la question existe en DB
        $questionExists = Db::getInstance()->getValue('SELECT COUNT(*) FROM `' . _DB_PREFIX_ . 'question` WHERE `id_question` = ' . (int)$idquestion);

        // Vérifier si l'ID de la réponse est lié à la question en DB
        $responseLinked = Db::getInstance()->getValue('SELECT COUNT(*) FROM `' . _DB_PREFIX_ . 'question_answer` WHERE `id_question` = ' . (int)$idquestion . ' AND `id_answer` = ' . (int)$idReponse);

        // Si la question existe et que l'ID de la réponse est lié à la question
        if ($questionExists && $responseLinked) {
            return true;
        }

        return false;
    }


    private function insertVote($idQuestion, $customerId)
    {
        $sql = 'INSERT INTO `' . _DB_PREFIX_ . 'vote` (`id_question`, `id_customer`) VALUES (:questionId, :customerId)';
        Db::getInstance()->execute($sql, ['questionId' => $questionId, 'customerId' => $customerId]);
    }

    private function insertVoteHistory($idQuestion, $idReponse, $customerId)
    {
        $sql = 'INSERT INTO `' . _DB_PREFIX_ . 'vote_history` (`id_question`, `id_answer`, `id_customer`) VALUES (' . (int)$idQuestion . ', ' . (int)$idReponse . ', ' . (int)$customerId . ')';
        Db::getInstance()->execute($sql);
    }

    private function jsonResponse($data, $statusCode)
    {
        http_response_code($statusCode);
        die(json_encode($data));
    }
    

}
